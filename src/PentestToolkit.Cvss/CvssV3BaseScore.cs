using System;
using System.Text;
using System.Text.RegularExpressions;

namespace PentestToolkit.Cvss
{
    public class CvssV3BaseScore
    {
        public double BaseScore => CalculateBaseScore();
        public CvssV3Enums.AttackComplexity AttackComplexity { get; set; }
        public CvssV3Enums.AttackVector AttackVector { get; set; }
        public CvssV3Enums.Availability Availability { get; set; }
        public CvssV3Enums.Confidentiality Confidentiality { get; set; }
        public CvssV3Enums.Integrity Integrity { get; set; }
        public CvssV3Enums.PrivilegesRequired PrivilegesRequired { get; set; }
        public CvssV3Enums.Scope Scope { get; set; }

        public CvssV3Enums.Severity Severity
        {
            get
            {
                var score = BaseScore;
                if (score == 0)
                {
                    return CvssV3Enums.Severity.None;
                }
                if (score >= 0.1 && score <= 3.9)
                {
                    return CvssV3Enums.Severity.Low;
                }
                if (score >= 4.0 && score <= 6.9)
                {
                    return CvssV3Enums.Severity.Medium;
                }
                if (score >= 7.0 && score <= 8.9)
                {
                    return CvssV3Enums.Severity.High;
                }
                if (score >= 9.0 && score <= 10.0)
                {
                    return CvssV3Enums.Severity.Critical;
                }

                throw new InvalidOperationException($"Invalid {nameof(BaseScore)} value \"{score}\"");
            }
        }

        public CvssV3Enums.UserInteraction UserInteraction { get; set; }

        public static CvssV3BaseScore FromCvssV2BaseScore(CvssV2BaseScore cvssV2BaseScore)
        {
            var cvssV3BaseScore = new CvssV3BaseScore();

            switch (cvssV2BaseScore.AccessVector)
            {
                case CvssV2Enums.AccessVector.Network:
                    cvssV3BaseScore.AttackVector = CvssV3Enums.AttackVector.Network;
                    break;

                case CvssV2Enums.AccessVector.AdjacentNetwork:
                    cvssV3BaseScore.AttackVector = CvssV3Enums.AttackVector.Adjacent;
                    break;
            }

            switch (cvssV2BaseScore.Authentication)
            {
                case CvssV2Enums.Authentication.None:
                    cvssV3BaseScore.PrivilegesRequired = CvssV3Enums.PrivilegesRequired.None;
                    break;
            }

            switch (cvssV2BaseScore.ConfidentialityImpact)
            {
                case CvssV2Enums.ConfidentialityImpact.Complete:
                    cvssV3BaseScore.Confidentiality = CvssV3Enums.Confidentiality.High;
                    break;

                case CvssV2Enums.ConfidentialityImpact.Partial:
                    cvssV3BaseScore.Confidentiality = CvssV3Enums.Confidentiality.Low;
                    break;

                case CvssV2Enums.ConfidentialityImpact.None:
                    cvssV3BaseScore.Confidentiality = CvssV3Enums.Confidentiality.None;
                    break;
            }

            switch (cvssV2BaseScore.IntegrityImpact)
            {
                case CvssV2Enums.IntegrityImpact.Complete:
                    cvssV3BaseScore.Integrity = CvssV3Enums.Integrity.High;
                    break;

                case CvssV2Enums.IntegrityImpact.Partial:
                    cvssV3BaseScore.Integrity = CvssV3Enums.Integrity.Low;
                    break;

                case CvssV2Enums.IntegrityImpact.None:
                    cvssV3BaseScore.Integrity = CvssV3Enums.Integrity.None;
                    break;
            }

            switch (cvssV2BaseScore.AvailabilityImpact)
            {
                case CvssV2Enums.AvailabilityImpact.Complete:
                    cvssV3BaseScore.Availability = CvssV3Enums.Availability.High;
                    break;

                case CvssV2Enums.AvailabilityImpact.Partial:
                    cvssV3BaseScore.Availability = CvssV3Enums.Availability.Low;
                    break;

                case CvssV2Enums.AvailabilityImpact.None:
                    cvssV3BaseScore.Availability = CvssV3Enums.Availability.None;
                    break;
            }

            return cvssV3BaseScore;
        }

        public static CvssV3BaseScore FromVectorString(string vectorString)
        {
            vectorString = vectorString ?? throw new ArgumentNullException(nameof(vectorString));
            if (string.IsNullOrWhiteSpace(vectorString) ||
                !Regex.IsMatch(vectorString, "^CVSS:3\\.0\\/((AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])\\/)*(AV:[NALP]|AC:[LH]|PR:[UNLH]|UI:[NR]|S:[UC]|[CIA]:[NLH]|E:[XUPFH]|RL:[XOTWU]|RC:[XURC]|[CIA]R:[XLMH]|MAV:[XNALP]|MAC:[XLH]|MPR:[XUNLH]|MUI:[XNR]|MS:[XUC]|M[CIA]:[XNLH])$"))
            {
                throw new ArgumentException("Not a valid CVSS V3 vector string, invalid format", nameof(vectorString));
            }

            var cvssV3BaseScore = new CvssV3BaseScore
            {
                AttackVector = VectorStringParser<CvssV3Enums.AttackVector>.Parse(vectorString),
                AttackComplexity = VectorStringParser<CvssV3Enums.AttackComplexity>.Parse(vectorString),
                PrivilegesRequired = VectorStringParser<CvssV3Enums.PrivilegesRequired>.Parse(vectorString),
                UserInteraction = VectorStringParser<CvssV3Enums.UserInteraction>.Parse(vectorString),
                Scope = VectorStringParser<CvssV3Enums.Scope>.Parse(vectorString),
                Confidentiality = VectorStringParser<CvssV3Enums.Confidentiality>.Parse(vectorString),
                Integrity = VectorStringParser<CvssV3Enums.Integrity>.Parse(vectorString),
                Availability = VectorStringParser<CvssV3Enums.Availability>.Parse(vectorString),
            };

            var hasAllRequiredValues = true;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.AttackVector != CvssV3Enums.AttackVector.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.AttackComplexity != CvssV3Enums.AttackComplexity.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.PrivilegesRequired != CvssV3Enums.PrivilegesRequired.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.UserInteraction != CvssV3Enums.UserInteraction.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.Scope != CvssV3Enums.Scope.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.Confidentiality != CvssV3Enums.Confidentiality.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.Integrity != CvssV3Enums.Integrity.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && cvssV3BaseScore.Availability != CvssV3Enums.Availability.NotSpecified;

            if (!hasAllRequiredValues)
            {
                throw new ArgumentException("Not a valid CVSS V3 vector string, missing required metric", nameof(vectorString));
            }

            return cvssV3BaseScore;
        }

        public string ToVectorString()
        {
            return ToVectorString(false);
        }

        public string ToVectorString(bool partial)
        {
            var builder = new StringBuilder();

            if (!partial)
            {
                builder.Append("CVSS:3.0");
                builder.Append("/");
            }
            builder.Append(VectorStringWriter<CvssV3Enums.AttackVector>.Write(AttackVector));
            builder.Append("/");
            builder.Append(VectorStringWriter<CvssV3Enums.AttackComplexity>.Write(AttackComplexity));
            builder.Append("/");
            builder.Append(VectorStringWriter<CvssV3Enums.PrivilegesRequired>.Write(PrivilegesRequired));
            builder.Append("/");
            builder.Append(VectorStringWriter<CvssV3Enums.UserInteraction>.Write(UserInteraction));
            builder.Append("/");
            builder.Append(VectorStringWriter<CvssV3Enums.Scope>.Write(Scope));
            builder.Append("/");
            builder.Append(VectorStringWriter<CvssV3Enums.Confidentiality>.Write(Confidentiality));
            builder.Append("/");
            builder.Append(VectorStringWriter<CvssV3Enums.Integrity>.Write(Integrity));
            builder.Append("/");
            builder.Append(VectorStringWriter<CvssV3Enums.Availability>.Write(Availability));

            return builder.ToString();
        }

        internal double CalculateBaseScore()
        {
            var hasAllRequiredValues = true;
            hasAllRequiredValues = hasAllRequiredValues && AttackVector != CvssV3Enums.AttackVector.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && AttackComplexity != CvssV3Enums.AttackComplexity.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && PrivilegesRequired != CvssV3Enums.PrivilegesRequired.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && UserInteraction != CvssV3Enums.UserInteraction.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && Scope != CvssV3Enums.Scope.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && Confidentiality != CvssV3Enums.Confidentiality.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && Integrity != CvssV3Enums.Integrity.NotSpecified;
            hasAllRequiredValues = hasAllRequiredValues && Availability != CvssV3Enums.Availability.NotSpecified;

            if (!hasAllRequiredValues)
            {
                return -1.0;
            }

            var impactSubScore = CalculateImpactSubScore();

            if (impactSubScore <= 0)
            {
                return 0;
            }

            var exploitabilitySubScore = CalculateExploitabilitySubScore();

            switch (Scope)
            {
                case CvssV3Enums.Scope.Unchanged:
                    return System.Math.Ceiling((Math.Min(impactSubScore + exploitabilitySubScore, 10)) * 10) / 10;

                case CvssV3Enums.Scope.Changed:
                    return System.Math.Ceiling((Math.Min(1.08 * (impactSubScore + exploitabilitySubScore), 10)) * 10) / 10;

                default:
                    throw new InvalidOperationException($"Unhandled {nameof(Scope)} value \"{Scope}\"");
            }
        }

        internal double CalculateExploitabilitySubScore() => 8.22 * CvssV3Weight.AttackVector[AttackVector] * CvssV3Weight.AttackComplexity[AttackComplexity] * CvssV3Weight.PrivilegesRequired[Scope][PrivilegesRequired] * CvssV3Weight.UserInteraction[UserInteraction];

        internal double CalculateImpactSubScore()
        {
            var impactSubScoreBase = CalculateImpactSubScoreBase();
            switch (Scope)
            {
                case CvssV3Enums.Scope.Unchanged:
                    return 6.42 * impactSubScoreBase;

                case CvssV3Enums.Scope.Changed:
                    return 7.52 * (impactSubScoreBase - 0.029) - 3.25 * Math.Pow(impactSubScoreBase - 0.02, 15);

                default:
                    throw new InvalidOperationException($"Unhandled {nameof(Scope)} value \"{Scope}\"");
            }
        }

        internal double CalculateImpactSubScoreBase() => 1 - ((1 - CvssV3Weight.Impact[Confidentiality]) * (1 - CvssV3Weight.Impact[Integrity]) * (1 - CvssV3Weight.Impact[Availability]));
    }
}
